define-syntax loop
  lambda | x
    syntax-case x | in
      \ _ function i in lst c1 c2 ...
        syntax
          function
            lambda [i] c1 c2 ...
            . lst
      \ _ function i j in lst1 lst2 c1 c2 ...
        syntax
          function
            lambda [i j] c1 c2 ...
            . lst1
            . lst2
      \ _ function i j k in lst1 lst2 lst3 c1 c2 ...
        syntax
          function
            lambda [i j k] c1 c2 ...
            . lst1
            . lst2
            . lst3

define-macro | gensyms a . rest
  quasiquote
    let*
      unquote
        calc-for i in a
          list i '(gensym)
      unquote-splicing rest

define-macro | for . x
  append '(loop for-each) x

define-method | for-each fn [s1 <promise>]
  stream-for-each fn s1

define-method | for-each fn [s1 <promise>] [s2 <promise>]
  stream-for-each fn s1 s2

define-method | for-each fn [s1 <promise>] [s2 <promise>] [s3 <promise>]
  stream-for-each fn s1 s2 s3

define-method | for-each fn [s1 <hashtable>]
  hash-for-each [lambda [x y] | fn [cons x y]] s1

define-macro | calc-for . x
  append '(loop map) x

define-syntax do-times
  lambda | x
    syntax-case x |
      \ _ count c1 c2 ...
        syntax
          let req || n count
            when | > n 0
              begin c1 c2 ...
              req | 1- n

define | all? pred lst
  cond
    [ null? lst ] #t
    [ pred | first lst ]
      all? pred | rest lst
    else #f

define | any? pred lst
  cond
    [ null? lst ] #f
    [ pred | first lst ]
      #t
    else
      any? pred | rest lst

define-syntax when
  lambda | x
    syntax-case x |
      \ _ cnd c1 c2 ...
        syntax
          if cnd
            begin c1 c2 ...

define-syntax unless
  lambda | x
    syntax-case x |
      \ _ cnd c1 c2 ...
        syntax
          if | not cnd
            begin c1 c2 ...

define-syntax bind
  lambda | x
    syntax-case x |
      \ _ name (a) b c ...
        syntax
          let || a | car name
            begin b c ...
      \ _ name (a b c ...) d e ...
        syntax
          let \\ a   | car name
                 tmp | cdr name
               bind tmp (b c ...) d e ...

define-syntax lambda-bind
  lambda | x
    syntax-case x |
      \ _ (a b ...) c d ...
        syntax
          lambda | tmp
            bind tmp (a b ...) c d ...

define | output-delimited func delim args
  unless | null? args
    let req || args args
      func | car args
      let || tail | cdr args
        unless | null? tail
          display delim
          req tail
  
define* | print #:key [before ""] [delim " "] [after "\n"] #:rest args
  display before
  let || tmp | make-q
    let req || args args
      cond
        \ null? args
          output-delimited display delim
            q->list tmp
        \ member [car args] '[ #:before #:delim #:after ] eq?
          req | cl-c___r dd args
        else
          enq! tmp | car args
          req | cdr args
  display after


define rest cdr

define q->list car
define q-top q-front
define | list->q lst
  let || q | cons lst #f
    sync-q! q
    . q

define | cl-car x
  if | null? x
    . '()
    car x

define | cl-cdr x
  if | null? x
    . '()
    cdr x

define | symbol-append . lst
  string->symbol | apply string-append | map symbol->string lst

define-macro | cl-c___r ___ x
  let* || lst | map string->symbol | map string | string->list | symbol->string ___
    let calc || lst lst
      if | null? lst
        . x
        let || fun | symbol-append 'cl-c [car lst] 'r
          list fun | calc | cdr lst

define-macro | define-cl-c___rs a b
  let || result | make-q
    enq! result 'begin
    let req
      \ level 0
        str   ""
      if | >= level a
        let*
          \ symbol    | string->symbol str
            full-name | symbol-append 'cl-c symbol 'r
          enq! result
            quasiquote
              define-macro | ,full-name __x__
                cl-c___r ,symbol __x__
      when | < level b
        req [1+ level] [string-append str "a"]
        req [1+ level] [string-append str "d"]
    q->list result
define-cl-c___rs 2 5

define | range a b
  make-stream
    lambda | state
      if | <= state b
        cons state | 1+ state
        . '()
    . a

define | list-range a b
  stream->list | range a b
