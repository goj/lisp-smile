define-macro | simple-syntax header . body
  let 
    \ name     | car header
      bindings | cdr header
      x        | gensym
    quasiquote
      define-syntax ,name
        lambda | ,x
          syntax-case ,x |
            \ _ ,@bindings
              syntax ,@body

define-macro | gensyms a . rest
  unless | list? a
    error "gensyms expects list of symbols as its first argument"
  quasiquote
    let
      unquote
        %~ map i in a
          list i '(gensym)
      unquote-splicing rest

simple-syntax | %% fn (x y ...) (a b ...) c1 c2 ...
  fn [lambda (x y ...) c1 c2 ...] a b ...

define-macro | % fn bindings . rest
  receive [collections body] | split-at rest | length bindings
    quasiquote
      %% ,fn ,bindings ,collections ,@body

define | make-eqv y
  lambda | x
    eqv? x y

define-macro | %~ fn . args
  receive [bindings rest] | break! [make-eqv 'in] args
    quasiquote
      % ,fn ,bindings ,@[cdr rest]

define loop %~

simple-syntax | with-cc cc a b ...
  call-with-current-continuation
    lambda [cc] a b ...

define-macro | for . x
  append '(%~ for-each) x

define-method | for-each fn [s1 <promise>]
  stream-for-each fn s1

define-method | for-each fn [s1 <promise>] [s2 <promise>]
  stream-for-each fn s1 s2

define-method | for-each fn [s1 <promise>] [s2 <promise>] [s3 <promise>]
  stream-for-each fn s1 s2 s3

define-method | for-each fn [s1 <hashtable>]
  hash-for-each [lambda [x y] | fn | cons x y] s1

define-macro | calc-for . x
  append '(%~ map) x

simple-syntax | do-times count c1 c2 ...
  let req || n count
    when | > n 0
      begin c1 c2 ...
      req | 1- n

simple-syntax | when cnd c1 c2 ...
  if cnd
    begin c1 c2 ...
    . *unspecified*

simple-syntax | unless cnd c1 c2 ...
  if cnd
    . *unspecified*
    begin c1 c2 ...

simple-syntax | bind lst (a b ...) c d ...
  receive (a b ...) (apply values lst) c d ...

define-macro | lambda-bind vars . body
  gensyms | tmp
    quasiquote
      lambda | ,tmp
        bind ,tmp ,vars ,@body
  
define | positional-only args
  let || tmp | make-q
    let req || args args
      cond
        \ null? args
          q->list tmp
        \ keyword? [car args]
          req | cl-cddr args
        else
          enq! tmp | car args
          req | cdr args
  
define* | print #:key [port | current-output-port] [func display] [before ""] [delim " "] [after "\n"] #:rest args
  display before port
  let || args | positional-only args
    unless | null? args
      let req || args args
        func [car args] port
        let || tail | cdr args
          unless | null? tail
            display delim port
            req tail
  display after port

define-macro | set-slots! instance . pairs
  unless | symbol? instance
    error "set-slots! requires symbol as it's first argument"
  unless | list? instance
    error "set-fields! expects list of lists as it's second argument"
  cons 'begin
    append
      %~ map pair in pairs
        if | pair? pair
          quasiquote
            slot-set! ,instance ',[car pair] ,@[cdr pair]
          error "set-fields! expects list of lists as it's second argument"
      . `(,instance)


define-macro | make-instance-and-setup class . initial-vals
  unless | symbol? class
    error "make-instance-and-setup requires class name as it's first argument"
  unless | list? initial-vals
    error "make-instance-and-setup expects list of lists as it's second argument"
  gensyms | result
    quasiquote
      let || ,result | make-instance ,class
        set-slots! ,result ,initial-vals


define rest cdr

define q->list car
define q-top q-front
define | list->q lst
  let || q | cons lst #f
    sync-q! q
    . q

define | cl-car x
  if | null? x
    . '()
    car x

define | cl-cdr x
  if | null? x
    . '()
    cdr x

define | symbol-append . lst
  string->symbol | apply string-append | map symbol->string lst

define-macro | cl-c___r ___ x
  let* || lst | map string->symbol | map string | string->list | symbol->string ___
    let calc || lst lst
      if | null? lst
        . x
        let || fun | symbol-append 'cl-c [car lst] 'r
          list fun | calc | cdr lst

define-macro | define-cl-c___rs a b
  let || result | make-q
    enq! result 'begin
    let req
      \ level 0
        mid-symbol '#{}#
      when | >= level a
        enq! result
          quasiquote
            define | ,[symbol-append 'cl-c mid-symbol 'r] __x__
              cl-c___r ,mid-symbol __x__
      when | < level b
        req [1+ level] [symbol-append mid-symbol 'a]
        req [1+ level] [symbol-append mid-symbol 'd]
    q->list result
define-cl-c___rs 2 5

define | range a b
  make-stream
    lambda | state
      if | <= state b
        cons state | 1+ state
        . '()
    . a

define | list-range a b
  stream->list | range a b

define-macro | define-nth-fn fn
  let || fun-name | symbol-append 'nth- fn
    gensyms | lst i
      quasiquote
        define | ,fun-name ,lst ,i
          if | zero? ,i
            ,fn ,lst
            ,fun-name [cdr ,lst] [1- ,i]
          
define-nth-fn car
define-nth-fn cdr
define-nth-fn car+cdr

simple-syntax | m->fn m
  lambda x
    primitive-eval | cons m x
    
define | none . args
  not | apply any args

define any?   any
define every? every
define none?  none


#|
define-syntax loop
  lambda | x
    syntax-case x | in
      \ _ function i in lst c1 c2 ...
        syntax
          function
            lambda [i] c1 c2 ...
            . lst
      \ _ function i j in lst1 lst2 c1 c2 ...
        syntax
          function
            lambda [i j] c1 c2 ...
            . lst1
            . lst2
      \ _ function i j k in lst1 lst2 lst3 c1 c2 ...
        syntax
          function
            lambda [i j k] c1 c2 ...
            . lst1
            . lst2
            . lst3
|#
